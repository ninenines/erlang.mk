# Core: Building applications.

CORE_APP_CASES = asn1 auto-git-id erlc-exclude erlc-opts erlc-opts-filter error generate-erl generate-erl-include generate-erl-prepend hrl hrl-recursive mib no-app no-makedep xrl xrl-include yrl yrl-include
CORE_APP_TARGETS = $(addprefix core-app-,$(CORE_APP_CASES))
CORE_APP_CLEAN_TARGETS = $(addprefix clean-,$(CORE_APP_TARGETS))

.PHONY: core-app $(CORE_APP_TARGETS) clean-core-app $(CORE_APP_CLEAN_TARGETS)

clean-core-app: $(CORE_APP_CLEAN_TARGETS)

$(CORE_APP_CLEAN_TARGETS):
	$t rm -rf $(APP_TO_CLEAN)/

core-app: $(CORE_APP_TARGETS)

core-app-asn1: build clean-core-app-asn1

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .asn1 files from Erlang/OTP"
	$t mkdir $(APP)/asn1/
	$t curl -s -o $(APP)/asn1/CAP.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/CAP.asn1
	$t curl -s -o $(APP)/asn1/Def.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/Def.asn1

	$i "Generate .erl files dependent from headers generated by .asn1 files"
	$t printf "%s\n" "-module(use_cap)." "-include(\"CAP.hrl\")." > $(APP)/src/use_cap.erl
	$t printf "%s\n" "-module(use_def)." "-include(\"Def.hrl\")." > $(APP)/src/use_def.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .asn1 file; check that only required files are rebuilt"
# The use_cap.erl gets touched because of its dependency to CAP.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/CAP.beam \
		$(APP)/ebin/use_cap.beam \
		$(APP)/include/CAP.asn1db \
		$(APP)/include/CAP.hrl \
		$(APP)/src/CAP.erl \
		$(APP)/src/use_cap.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/asn1/CAP.asn1
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/asn1/CAP.asn1 | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/asn1/CAP.asn1
	$t test -f $(APP)/asn1/Def.asn1
	$t test -f $(APP)/include/unrelated.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_cap.erl
	$t test -f $(APP)/src/use_def.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/CAP.asn1db
	$t test ! -e $(APP)/include/CAP.hrl
	$t test ! -e $(APP)/include/Def.asn1db
	$t test ! -e $(APP)/include/Def.hrl
	$t test ! -e $(APP)/src/CAP.erl
	$t test ! -e $(APP)/src/Def.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-auto-git-id: build clean-core-app-auto-git-id

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Make it a git repository"
	$t cd $(APP) && \
		git init -q && \
		git config user.email "testsuite@erlang.mk" && \
		git config user.name "test suite" && \
		git add . && \
		git commit -q -m "Tests"

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

ifdef LEGACY
# Legacy replaces {id, "git"} always regardless of built as a dependency.
	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"
else
# If there is no .app.src though, only fill in id when built as a dependency.
	$i "Check that the generated .app file has no id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, []} = application:get_key($(APP), id), \
		halt()"
endif

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Build the application with IS_DEP=1"
	$t $(MAKE) -C $(APP) IS_DEP=1 $v

	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"

core-app-erlc-exclude: build clean-core-app-erlc-exclude

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Exclude boy.erl from the compilation"
	$t echo "ERLC_EXCLUDE = boy" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that boy.erl was not compiled"
	$t test ! -e $(APP)/ebin/boy.beam

	$i "Check that the application was compiled correctly (without boy.erl)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-erlc-opts: build clean-core-app-erlc-opts

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define an empty ERLC_OPTS (without debug_info)"
	$t echo "ERLC_OPTS =" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-erlc-opts-filter: build clean-core-app-erlc-opts-filter

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define ERLC_OPTS filtering out debug_info"
	$t echo "ERLC_OPTS := \$$(filter-out +debug_info,\$$(ERLC_OPTS))" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-error: build clean-core-app-error

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a bad .erl files"
	$t touch $(APP)/src/breaking.erl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Check that trying to build returns non-zero"
	$t if $(MAKE) -C $(APP) $v; then false; fi

core-app-generate-erl: build clean-core-app-generate-erl

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/script.sh
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-include: build clean-core-app-generate-erl-include

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@; echo \"-include(\\\"included.hrl\\\").\" >> \$$@" >> $(APP)/Makefile

	$i "Generate the .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/included.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/include/included.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/included.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-prepend: build clean-core-app-generate-erl-prepend

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Generate a Makefile and prepend rules that generate a .erl module"
	$t echo "PROJECT = $(APP)" > $(APP)/Makefile
	$t echo ".DEFAULT_GOAL = all" >> $(APP)/Makefile
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile
	$t echo "include erlang.mk" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/script.sh
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl: build clean-core-app-hrl

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/include/red.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-recursive: build clean-core-app-hrl-recursive

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/pill.hrl
	$t echo "-include(\"pill.hrl\")." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the deepest .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl and pill.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/include/pill.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/pill.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-mib: build clean-core-app-mib

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .mib files from Erlang/OTP"
	$t mkdir $(APP)/mibs/
	$t curl -s -o $(APP)/mibs/EX1-MIB.mib $(OTP_MASTER)/lib/snmp/examples/ex1/EX1-MIB.mib
	$t curl -s -o $(APP)/mibs/OTP-REG.mib $(OTP_MASTER)/lib/otp_mibs/mibs/OTP-REG.mib

	$i "Generate .erl files dependent from headers generated by .mib files"
	$t printf "%s\n" "-module(use_v1)." "-include(\"EX1-MIB.hrl\")." > $(APP)/src/use_v1.erl
	$t printf "%s\n" "-module(use_v2)." "-include(\"OTP-REG.hrl\")." > $(APP)/src/use_v2.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .mib file; check that only required files are rebuilt"
# The use_v1.erl gets touched because of its dependency to EX1-MIB.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_v1.beam \
		$(APP)/include/EX1-MIB.hrl \
		$(APP)/priv/mibs/EX1-MIB.bin \
		$(APP)/src/use_v1.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/mibs/EX1-MIB.mib
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/mibs/EX1-MIB.mib | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/unrelated.hrl
	$t test -f $(APP)/mibs/EX1-MIB.mib
	$t test -f $(APP)/mibs/OTP-REG.mib
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_v1.erl
	$t test -f $(APP)/src/use_v2.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/EX1-MIB.hrl
	$t test ! -e $(APP)/include/OTP-REG.hrl
	$t test ! -e $(APP)/priv/mibs/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-no-app: build clean-core-app-no-app

	$i "Bootstrap a project without an OTP library"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v
	$t rm -rf $(APP)/src

	$i "Build the project"
	$t $(MAKE) -C $(APP) $v

core-app-no-makedep: build clean-core-app-no-makedep

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set NO_MAKEDEP ?= 1 in the Makefile"
	$t sed -i.bak '2i\
NO_MAKEDEP ?= 1\
' $(APP)/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/include/red.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; disable NO_MAKEDEP and check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/include/red.hrl
	$t NO_MAKEDEP= $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl: build clean-core-app-xrl

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .xrl files from Robert"
	$t curl -s -o $(APP)/src/erlang_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/erlang_scan.xrl
	$t curl -s -o $(APP)/src/lfe_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/lfe_scan.xrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/erlang_scan.beam \
		$(APP)/src/erlang_scan.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/erlang_scan.xrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/erlang_scan.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/erlang_scan.xrl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/lfe_scan.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/erlang_scan.erl
	$t test ! -e $(APP)/src/lfe_scan.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl-include: build clean-core-app-xrl-include

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .xrl file with numerous includes from Gordon"
	$t curl -s -o $(APP)/src/xfl_lexer.xrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/formula_engine-1.0/priv/xfl_lexer.xrl
	$t curl -s -o $(APP)/src/errvals.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/errvals.hrl
	$t curl -s -o $(APP)/src/muin_proc_dict.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/muin_proc_dict.hrl
	$t curl -s -o $(APP)/src/muin_records.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/muin_records.hrl
	$t curl -s -o $(APP)/src/typechecks.hrl https://raw.githubusercontent.com/hypernumbers/hypernumbers/master/lib/hypernumbers-1.0/include/typechecks.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/xfl_lexer.xrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xfl_lexer.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included directly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/typechecks.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/typechecks.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included indirectly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/errvals.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/errvals.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/errvals.hrl
	$t test -f $(APP)/src/muin_proc_dict.hrl
	$t test -f $(APP)/src/muin_records.hrl
	$t test -f $(APP)/src/typechecks.hrl
	$t test -f $(APP)/src/xfl_lexer.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xfl_lexer.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl: build clean-core-app-yrl

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .yrl files from Erlang/OTP"
	$t curl -s -o $(APP)/src/xmerl_xpath_parse.yrl $(OTP_MASTER)/lib/xmerl/src/xmerl_xpath_parse.yrl
	$t curl -s -o $(APP)/src/xref_parser.yrl $(OTP_MASTER)/lib/tools/src/xref_parser.yrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xref_parser.beam \
		$(APP)/src/xref_parser.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/xref_parser.yrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xref_parser.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/xmerl_xpath_parse.yrl
	$t test -f $(APP)/src/xref_parser.yrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xmerl_xpath_parse.erl
	$t test ! -e $(APP)/src/xref_parser.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-include: build clean-core-app-yrl-include

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .yrl file with includes from Erlang/OTP"
	$t curl -s -o $(APP)/src/core_parse.yrl $(OTP_MASTER)/lib/compiler/src/core_parse.yrl
	$t curl -s -o $(APP)/src/core_parse.hrl $(OTP_MASTER)/lib/compiler/src/core_parse.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/core_parse.yrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file included; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t touch $(APP)/src/core_parse.hrl
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/core_parse.hrl
	$t test -f $(APP)/src/core_parse.yrl
	$t test -f $(APP)/src/girl.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/core_parse.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"
