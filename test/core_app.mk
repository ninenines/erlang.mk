# Core: Building applications.

core_app_TARGETS = $(call list_targets,core-app)

.PHONY: core-app $(core_app_TARGETS)

core-app: $(core_app_TARGETS)

ifdef LEGACY
core-app-appsrc-change: init

	$i "Bootstrap a new OTP application named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap $v

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Touch the .app.src file; check that only the .app file gets rebuilt"
	$t printf "%s\n" $(APP)/ebin/$(APP).app > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/$(APP).app.src
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/$(APP).app.src | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT
endif

core-app-appup: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a .appup file"
	$t touch $(APP)/src/$(APP).appup

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the appup file was copied into ebin/"
	$t test -f $(APP)/ebin/$(APP).appup

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the source file still exists"
	$t test -f $(APP)/src/$(APP).appup

	$i "Check that the file copied into ebin/ was removed"
	$t test ! -e $(APP)/ebin/$(APP).appup

core-app-asn1: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .asn1 files from Erlang/OTP"
	$t mkdir $(APP)/asn1/
	$t curl -s -o $(APP)/asn1/CAP.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/CAP.asn1
	$t curl -s -o $(APP)/asn1/Def.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/Def.asn1

	$i "Generate .erl files dependent from headers generated by .asn1 files"
	$t printf "%s\n" "-module(use_cap)." "-include(\"CAP.hrl\")." > $(APP)/src/use_cap.erl
	$t printf "%s\n" "-module(use_def)." "-include(\"Def.hrl\")." > $(APP)/src/use_def.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .asn1 file; check that only required files are rebuilt"
# The use_cap.erl gets touched because of its dependency to CAP.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/CAP.beam \
		$(APP)/ebin/use_cap.beam \
		$(APP)/include/CAP.asn1db \
		$(APP)/include/CAP.hrl \
		$(APP)/src/CAP.erl \
		$(APP)/src/use_cap.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/asn1/CAP.asn1
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/asn1/CAP.asn1 | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/asn1/CAP.asn1
	$t test -f $(APP)/asn1/Def.asn1
	$t test -f $(APP)/include/unrelated.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_cap.erl
	$t test -f $(APP)/src/use_def.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/CAP.asn1db
	$t test ! -e $(APP)/include/CAP.hrl
	$t test ! -e $(APP)/include/Def.asn1db
	$t test ! -e $(APP)/include/Def.hrl
	$t test ! -e $(APP)/src/CAP.erl
	$t test ! -e $(APP)/src/Def.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/ebin/use_cap.beam
	$t test -f $(APP)/ebin/use_def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t test -f $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t test -f $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def', use_cap, use_def]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Build the application with ERLC_ASN1_OPTS set"
	$t echo "ERLC_ASN1_OPTS += +'{record_name_prefix,\"FOO-\"}'" >> $(APP)/Makefile
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was built with ERLC_ASN1_OPTS set"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
	  Attrs = 'Def':module_info(attributes), \
		Asn1Info = proplists:get_value(asn1_info, Attrs), \
		Opts = proplists:get_value(options, Asn1Info), \
		true = lists:member({record_name_prefix, \"FOO-\"}, Opts), \
		halt()"

core-app-asn1-maps: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set ERLC_ASN1_OPTS = +maps in the Makefile"
	$t perl -ni.bak -e 'print;if ($$.==1) {print "ERLC_ASN1_OPTS = +maps\n"}' $(APP)/Makefile

	$i "Download .asn1 files from Erlang/OTP"
	$t mkdir $(APP)/asn1/
	$t curl -s -o $(APP)/asn1/CAP.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/CAP.asn1
	$t curl -s -o $(APP)/asn1/Def.asn1 $(OTP_MASTER)/lib/asn1/test/asn1_SUITE_data/Def.asn1

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/CAP.beam
	$t test -f $(APP)/ebin/Def.beam
	$t test -f $(APP)/include/CAP.asn1db
	$t ! test -e $(APP)/include/CAP.hrl
	$t test -f $(APP)/include/Def.asn1db
	$t ! test -e $(APP)/include/Def.hrl
	$t test -f $(APP)/src/CAP.erl
	$t test -f $(APP)/src/Def.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = ['CAP', 'Def']} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-auto-git-id: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Make it a git repository"
	$t cd $(APP) && \
		git init -q -b master && \
		git config user.email "testsuite@erlang.mk" && \
		git config user.name "test suite" && \
		git add . && \
		git commit -q --no-gpg-sign -m "Tests"

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

ifdef LEGACY
# Legacy replaces {id, "git"} always regardless of built as a dependency.
	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"
else
# If there is no .app.src though, only fill in id when built as a dependency.
	$i "Check that the generated .app file has no id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, []} = application:get_key($(APP), id), \
		halt()"
endif

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Build the application with IS_DEP=1"
	$t $(MAKE) -C $(APP) IS_DEP=1 $v

	$i "Check that the generated .app file has an id key"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, ID} = application:get_key($(APP), id), \
		true = ID =/= [], \
		halt()"

core-app-compile-first: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl
	$t echo "-module(first)." > $(APP)/src/first.erl

	$i "Define COMPILE_FIRST"
	$t echo "COMPILE_FIRST = first" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, first, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-compile-first-sub-directory: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl
	$t mkdir $(APP)/src/sub/
	$t echo "-module(first)." > $(APP)/src/sub/first.erl

	$i "Define COMPILE_FIRST with a module in a sub-directory"
	$t echo "COMPILE_FIRST = sub/first" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, first, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

ifndef LEGACY
core-app-env: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define PROJECT_ENV"
	$t echo "PROJECT_ENV = [{test_key, test_value}]" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, test_value} = application:get_env($(APP), test_key), \
		halt()"

	$i "Define PROJECT_ENV with escape in string, special char"
	$t echo "PROJECT_ENV = [{test_atom, '\\\$$\$$test'}, {test_key, \"\\\"test_\\tvalue\\\"\"}]" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, \"\\\"test_\\tvalue\\\"\"} = application:get_env($(APP), test_key), \
		{ok, '\\\$$test'} = application:get_env($(APP), test_atom), \
		halt()"

core-app-env-invalid: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define an invalid PROJECT_ENV"
	$t echo "PROJECT_ENV = [{test_key, test_value" >> $(APP)/Makefile

	$i "Build the application"
	$t ! $(MAKE) -C $(APP) $v
endif

core-app-erlc-exclude: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Exclude boy.erl from the compilation"
	$t echo "ERLC_EXCLUDE = boy" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that boy.erl was not compiled"
	$t test ! -e $(APP)/ebin/boy.beam

	$i "Check that the application was compiled correctly (without boy.erl)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-erlc-opts: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define an empty ERLC_OPTS (without debug_info)"
	$t echo "ERLC_OPTS =" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-erlc-opts-filter: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define ERLC_OPTS filtering out debug_info"
	$t echo "ERLC_OPTS := \$$(filter-out +debug_info,\$$(ERLC_OPTS))" >> $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly (without debug_info)"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		false = proplists:is_defined(debug_info, proplists:get_value(options, boy:module_info(compile))), \
		false = proplists:is_defined(debug_info, proplists:get_value(options, girl:module_info(compile))), \
		halt()"

core-app-erlc-symlink: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/girl.erl

	$i "Symlink .erl file"
	$t ln -s ../girl.erl $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-error: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a bad .erl files"
	$t touch $(APP)/src/breaking.erl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Check that trying to build returns non-zero"
	$t ! $(MAKE) -C $(APP) $v

ifndef LEGACY
core-app-extra-keys: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Define PROJECT_APP_EXTRA_KEYS"
	$t printf "define PROJECT_APP_EXTRA_KEYS\n\t{maxT, 10000},\n\t{non_standard_key, test_value}\nendef\n" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok, 10000} = application:get_key($(APP), maxT), \
		AppFile = filename:join(code:lib_dir($(APP), ebin), atom_to_list($(APP)) ++ \".app\"), \
		{ok, [App]} = file:consult(AppFile), \
		{application, $(APP), Props} = App, \
		test_value = proplists:get_value(non_standard_key, Props),\
		halt()"

	$i "Define PROJECT_APP_EXTRA_KEYS with escape in string, special char"
	$t echo "PROJECT_APP_EXTRA_KEYS = {non_standard_atom, '\\\$$\$$my_app'}, {non_standard_string, \"\\\"test_\\tvalue\\\"\"}" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		AppFile = filename:join(code:lib_dir($(APP), ebin), atom_to_list($(APP)) ++ \".app\"), \
		{ok, [App]} = file:consult(AppFile), \
		{application, $(APP), Props} = App, \
		'\\\$$my_app' = proplists:get_value(non_standard_atom, Props),\
		\"\\\"test_\\tvalue\\\"\" = proplists:get_value(non_standard_string, Props),\
		halt()"
endif

core-app-generate-erl: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/script.sh
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-include: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Append rules to the Makefile to generate a .erl module"
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@; echo \"-include(\\\"included.hrl\\\").\" >> \$$@" >> $(APP)/Makefile

	$i "Generate the .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/included.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/included.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/included.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-generate-erl-prepend: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a fake script file to be used as dependency"
	$t touch $(APP)/script.sh

	$i "Generate a Makefile and prepend rules that generate a .erl module"
	$t echo "PROJECT = $(APP)" > $(APP)/Makefile
	$t echo ".DEFAULT_GOAL = all" >> $(APP)/Makefile
	$t echo "\$$(PROJECT).d:: src/generated.erl" >> $(APP)/Makefile
	$t echo "src/generated.erl:: script.sh; echo \"-module(generated).\" > \$$@" >> $(APP)/Makefile
	$t echo "include erlang.mk" >> $(APP)/Makefile

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the script file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/generated.beam \
		$(APP)/src/generated.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/script.sh
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/script.sh | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/script.sh
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl

	$i "Check that the generated .erl file still exists"
	$t test -f $(APP)/src/generated.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Add a rule to remove the generated .erl file on clean"
	$t echo "clean:: ; rm src/generated.erl" >> $(APP)/Makefile

	$i "Clean the application again"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that the generated .erl file was removed"
	$t test ! -e $(APP)/src/generated.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/generated.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/generated.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, generated, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-recursive: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/pill.hrl
	$t echo "-include(\"pill.hrl\")." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the deepest .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl and pill.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/pill.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/pill.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-makefile-change: init

	$i "Bootstrap a new OTP application named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap $v

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Touch the Makefile; check that all files get rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/$(APP)_app.beam \
		$(APP)/ebin/$(APP)_sup.beam \
		$(APP)/src/$(APP)_app.erl \
		$(APP)/src/$(APP)_sup.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/Makefile
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/Makefile -not -path "$(APP)/.erlang.mk/*" | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

core-app-mib: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .mib files from Erlang/OTP"
	$t mkdir $(APP)/mibs/
	$t curl -s -o $(APP)/mibs/EX1-MIB.mib $(OTP_MASTER)/lib/snmp/examples/ex1/EX1-MIB.mib
	$t curl -s -o $(APP)/mibs/OTP-REG.mib $(OTP_MASTER)/lib/snmp/mibs/OTP-REG.mib

	$i "Generate .erl files dependent from headers generated by .mib files"
	$t printf "%s\n" "-module(use_v1)." "-include(\"EX1-MIB.hrl\")." > $(APP)/src/use_v1.erl
	$t printf "%s\n" "-module(use_v2)." "-include(\"OTP-REG.hrl\")." > $(APP)/src/use_v2.erl

	$i "Generate an unrelated .hrl file"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/unrelated.hrl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .mib file; check that only required files are rebuilt"
# The use_v1.erl gets touched because of its dependency to EX1-MIB.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_v1.beam \
		$(APP)/include/EX1-MIB.hrl \
		$(APP)/priv/mibs/EX1-MIB.bin \
		$(APP)/src/use_v1.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/mibs/EX1-MIB.mib
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/mibs/EX1-MIB.mib | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/unrelated.hrl
	$t test -f $(APP)/mibs/EX1-MIB.mib
	$t test -f $(APP)/mibs/OTP-REG.mib
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_v1.erl
	$t test -f $(APP)/src/use_v2.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/include/EX1-MIB.hrl
	$t test ! -e $(APP)/include/OTP-REG.hrl
	$t test ! -e $(APP)/priv/mibs/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_v1.beam
	$t test -f $(APP)/ebin/use_v2.beam
	$t test -f $(APP)/include/EX1-MIB.hrl
	$t test -f $(APP)/include/OTP-REG.hrl
	$t test -f $(APP)/priv/mibs/EX1-MIB.bin
	$t test -f $(APP)/priv/mibs/OTP-REG.bin

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_v1, use_v2]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

ifndef LEGACY
core-app-name-special-char: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set PROJECT_DESCRIPTION = test % in the Makefile"
	$t echo "PROJECT_DESCRIPTION = test %" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:load($(APP)), \
		{ok,\"test %\"} = application:get_key($(APP), description), \
		halt()"
endif

core-app-no-app: init

	$i "Bootstrap a project without an OTP library"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v
	$t rm -rf $(APP)/src

	$i "Build the project"
	$t $(MAKE) -C $(APP) $v

core-app-no-makedep: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Set NO_MAKEDEP ?= 1 in the Makefile"
	$t perl -ni.bak -e 'print;if ($$.==1) {print "NO_MAKEDEP ?= 1\n"}' $(APP)/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; disable NO_MAKEDEP and check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t NO_MAKEDEP= $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-project-mod: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate an application module"
	$t printf "%s\n" \
		"-module(app_mod)." \
		"-export([start/2, stop/1])." \
		"start(_StartType, _StartArgs) -> {ok, self()}." \
		"stop(_State) -> ok." > $(APP)/src/app_mod.erl

	$i "Build the application with PROJECT_MOD"
	$t $(MAKE) -C $(APP) PROJECT_MOD=app_mod $v

	$i "Check that the application starts correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval "ok = application:start($(APP)), halt()"

core-app-pt: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate a parse_transform module"
	$t printf "%s\n" \
		"-module(my_pt)." \
		"-export([parse_transform/2])." \
		"parse_transform(Forms, _) ->" \
		"	io:format(\"# Running my_pt parse_transform.~n\")," \
		"	Forms." > $(APP)/src/my_pt.erl

	$i "Generate a .erl file that uses the my_pt parse_transform"
	$t printf "%s\n" \
		"-module(my_user)." \
		"-compile({parse_transform, my_pt})." > $(APP)/src/my_user.erl

	$i "Build the application; confirm the parse_transform is used"
	$t $(MAKE) -C $(APP) 2>&1 | grep "Running my_pt parse_transform."

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [my_pt, my_user]} = application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-pt-erlc-opts: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Bootstrap a new OTP library in $(APP)/deps/my_pt_dep"
	$t mkdir -p $(APP)/deps/my_pt_dep/
	$t cp ../erlang.mk $(APP)/deps/my_pt_dep/
	$t $(MAKE) -C $(APP)/deps/my_pt_dep/ -f erlang.mk bootstrap-lib $v

	$i "Generate a parse_transform module in my_pt_dep"
	$t printf "%s\n" \
		"-module(my_pt)." \
		"-export([parse_transform/2])." \
		"parse_transform(Forms, _) ->" \
		"	io:format(\"# Running my_pt parse_transform.~n\")," \
		"	Forms." > $(APP)/deps/my_pt_dep/src/my_pt.erl

	$i "Add my_pt_dep to the list of dependencies"
	$t perl -ni.bak -e 'print;if ($$.==1) {print "BUILD_DEPS = my_pt_dep\n"}' $(APP)/Makefile

	$i "Generate .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Add the my_pt parse_transform to ERLC_OPTS"
	$t echo "ERLC_OPTS += +'{parse_transform, my_pt}'" >> $(APP)/Makefile

	$i "Build the application; confirm the parse_transform is used"
	$t $(MAKE) -C $(APP) 2>&1 | grep "Running my_pt parse_transform."

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl]} = application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .xrl files from Robert"
	$t curl -s -o $(APP)/src/erlang_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/erlang_scan.xrl
	$t curl -s -o $(APP)/src/lfe_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/lfe_scan.xrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/erlang_scan.beam \
		$(APP)/src/erlang_scan.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/erlang_scan.xrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/erlang_scan.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/erlang_scan.xrl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/lfe_scan.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/erlang_scan.erl
	$t test ! -e $(APP)/src/lfe_scan.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/erlang_scan.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/lfe_scan.beam
	$t test -f $(APP)/src/erlang_scan.erl
	$t test -f $(APP)/src/lfe_scan.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, erlang_scan, girl, lfe_scan]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-xrl-help: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download an .xrl file from Robert"
	$t curl -s -o $(APP)/src/erlang_scan.xrl https://raw.githubusercontent.com/rvirding/leex/master/examples/erlang_scan.xrl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Run 'make help'"
	$t $(MAKE) -C $(APP) help $v

	$i "Check that no files were compiled"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/$(APP).app
	$t test ! -e $(APP)/ebin/erlang_scan.beam
	$t test ! -e $(APP)/src/erlang_scan.erl

core-app-xrl-include: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .xrl file with numerous includes from Gordon"
	$t curl -s -o $(APP)/src/xfl_lexer.xrl https://raw.githubusercontent.com/essen/hypernumbers/master/lib/formula_engine-1.0/priv/xfl_lexer.xrl
	$t curl -s -o $(APP)/src/errvals.hrl https://raw.githubusercontent.com/essen/hypernumbers/master/lib/hypernumbers-1.0/include/errvals.hrl
	$t curl -s -o $(APP)/src/muin_proc_dict.hrl https://raw.githubusercontent.com/essen/hypernumbers/master/lib/hypernumbers-1.0/include/muin_proc_dict.hrl
	$t curl -s -o $(APP)/src/muin_records.hrl https://raw.githubusercontent.com/essen/hypernumbers/master/lib/hypernumbers-1.0/include/muin_records.hrl
	$t curl -s -o $(APP)/src/typechecks.hrl https://raw.githubusercontent.com/essen/hypernumbers/master/lib/hypernumbers-1.0/include/typechecks.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Disable warnings; our test .xrl files aren't perfect"
	$t echo "ERLC_OPTS=+debug_info" >> $(APP)/Makefile

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .xrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/xfl_lexer.xrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xfl_lexer.xrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included directly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/typechecks.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/typechecks.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch a .hrl file included indirectly; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xfl_lexer.beam \
		$(APP)/src/xfl_lexer.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/errvals.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/errvals.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/errvals.hrl
	$t test -f $(APP)/src/muin_proc_dict.hrl
	$t test -f $(APP)/src/muin_records.hrl
	$t test -f $(APP)/src/typechecks.hrl
	$t test -f $(APP)/src/xfl_lexer.xrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xfl_lexer.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xfl_lexer.beam
	$t test -f $(APP)/src/xfl_lexer.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xfl_lexer]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download .yrl files from Erlang/OTP"
	$t curl -s -o $(APP)/src/xmerl_xpath_parse.yrl $(OTP_MASTER)/lib/xmerl/src/xmerl_xpath_parse.yrl
	$t curl -s -o $(APP)/src/xref_parser.yrl $(OTP_MASTER)/lib/tools/src/xref_parser.yrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/xref_parser.beam \
		$(APP)/src/xref_parser.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/xref_parser.yrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/xref_parser.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/girl.erl
	$t test -f $(APP)/src/xmerl_xpath_parse.yrl
	$t test -f $(APP)/src/xref_parser.yrl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/xmerl_xpath_parse.erl
	$t test ! -e $(APP)/src/xref_parser.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/xmerl_xpath_parse.beam
	$t test -f $(APP)/ebin/xref_parser.beam
	$t test -f $(APP)/src/xmerl_xpath_parse.erl
	$t test -f $(APP)/src/xref_parser.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, xmerl_xpath_parse, xref_parser]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-header: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create a .yrl file"
	$t echo "Nonterminals E T F." > $(APP)/src/y_parse.yrl
	$t echo "Terminals '+' '*' '(' ')' number." >> $(APP)/src/y_parse.yrl
	$t echo "Rootsymbol E." >> $(APP)/src/y_parse.yrl
	$t echo "E -> E '+' T: {'\$$2', '\$$1', '\$$3'}." >> $(APP)/src/y_parse.yrl
	$t echo "E -> T : '\$$1'." >> $(APP)/src/y_parse.yrl
	$t echo "T -> T '*' F: {'\$$2', '\$$1', '\$$3'}." >> $(APP)/src/y_parse.yrl
	$t echo "T -> F : '\$$1'." >> $(APP)/src/y_parse.yrl
	$t echo "F -> '(' E ')' : '\$$2'." >> $(APP)/src/y_parse.yrl
	$t echo "F -> number : '\$$1'. " >> $(APP)/src/y_parse.yrl

	$i "Create the yrl header file"
	$t mkdir $(APP)/include
	$t echo "-export([forty_two/0])." > $(APP)/include/yecc_header.hrl
# A bunch of gobbldygook we don't actually care about, they just
# need to exist so we don't get errors.
	$t echo "-export([yeccpars1/5])." >> $(APP)/include/yecc_header.hrl
	$t echo "-export([yeccerror/1])." >> $(APP)/include/yecc_header.hrl
	$t echo "yeccpars1(_,_,_,_,_) -> throw(not_implemented)." >> $(APP)/include/yecc_header.hrl
	$t echo "yeccerror(_) -> throw(not_implemented)." >> $(APP)/include/yecc_header.hrl
# Required bits done, now part we'll actually test for.
	$t echo "forty_two() -> 42." >> $(APP)/include/yecc_header.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t YRL_ERLC_OPTS="-I include/yecc_header.hrl" $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/ebin/y_parse.beam
	$t test -f $(APP)/src/y_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, y_parse]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Check the built yecc module used the header"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		{module, y_parse} = code:load_file(y_parse), \
		42 = y_parse:forty_two(), \
		halt()"

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, girl, y_parse]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-include: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Download a .yrl file with includes from Erlang/OTP"
	$t curl -s -o $(APP)/src/core_parse.yrl $(OTP_MASTER)/lib/compiler/src/core_parse.yrl
	$t curl -s -o $(APP)/src/core_parse.hrl $(OTP_MASTER)/lib/compiler/src/core_parse.hrl

	$i "Generate unrelated .erl files"
	$t echo "-module(boy)." > $(APP)/src/boy.erl
	$t echo "-module(girl)." > $(APP)/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .yrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/core_parse.yrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.yrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the .hrl file included; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/core_parse.beam \
		$(APP)/src/core_parse.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/core_parse.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/core_parse.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/boy.erl
	$t test -f $(APP)/src/core_parse.hrl
	$t test -f $(APP)/src/core_parse.yrl
	$t test -f $(APP)/src/girl.erl

	$i "Check that all build artifacts are removed, including intermediates"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/
	$t test ! -e $(APP)/src/core_parse.erl

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/boy.beam
	$t test -f $(APP)/ebin/core_parse.beam
	$t test -f $(APP)/ebin/girl.beam
	$t test -f $(APP)/src/core_parse.erl

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [boy, core_parse, girl]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-yrl-test-build-then-normal-build: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Create the parser .yrl file"
	$t printf "%s\n" \
		"Nonterminals top." \
		"Terminals plus num." \
		"Rootsymbol top." \
		"top -> num plus num : {'$1', '$3'}." > $(APP)/src/$(APP)_parser.yrl

	$i "Create the test suite"
	$t mkdir $(APP)/test
	$t printf "%s\n" \
		"-module(test_SUITE)." \
		"-export([all/0, test/1])." \
		"all() -> [test]." \
		"test(_) -> 0=0." > $(APP)/test/test_SUITE.erl

	$i "Build the application in test mode"
	$t $(MAKE) -C $(APP) ct $v

	$i "Build the application in normal mode"
	$t $(MAKE) -C $(APP) $v

core-app-hrl-include-lib: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-include-lib-recursive: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t mkdir $(APP)/include/
	$t touch $(APP)/include/blue.hrl $(APP)/include/pill.hrl
	$t echo "-include_lib(\"pill.hrl\")." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the deepest .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl and pill.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/include/pill.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/include/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/include/blue.hrl
	$t test -f $(APP)/include/pill.hrl
	$t test -f $(APP)/include/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-multiapps-include-lib: init

	$i "Create a multi application repository with no root application"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t echo "include erlang.mk" > $(APP)/Makefile

	$i "Create a new application named my_app"
	$t $(MAKE) -C $(APP) new-lib in=my_app $v

	$i "Create a new library named my_lib"
	$t $(MAKE) -C $(APP) new-lib in=my_lib $v

	$i "Add my_lib as LOCAL_DEPS of my_app"
	$t echo "LOCAL_DEPS = my_lib" >> $(APP)/apps/my_app/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/apps/my_lib/include/
	$t touch $(APP)/apps/my_lib/include/blue.hrl $(APP)/apps/my_lib/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"my_lib/include/blue.hrl\")." > $(APP)/apps/my_app/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"my_lib/include/red.hrl\")." > $(APP)/apps/my_app/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/apps/my_app/my_app.d \
		$(APP)/apps/my_app/ebin/my_app.app \
		$(APP)/apps/my_app/ebin/use_red.beam \
		$(APP)/apps/my_app/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/apps/my_lib/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP)/apps/my_app -type f -newer $(APP)/apps/my_lib/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/apps/my_lib/Makefile
	$t test -f $(APP)/apps/my_lib/include/blue.hrl
	$t test -f $(APP)/apps/my_lib/include/red.hrl
	$t test -f $(APP)/apps/my_app/Makefile
	$t test -f $(APP)/apps/my_app/src/use_blue.erl
	$t test -f $(APP)/apps/my_app/src/use_red.erl
ifdef LEGACY
	$t test -f $(APP)/apps/my_lib/src/my_lib.app.src
	$t test -f $(APP)/apps/my_app/src/my_app.app.src
endif

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/apps/my_lib/my_app.d
	$t test ! -e $(APP)/apps/my_lib/ebin/
	$t test ! -e $(APP)/apps/my_app/my_app.d
	$t test ! -e $(APP)/apps/my_app/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-multiapps-include-lib-recursive: init

	$i "Create a multi application repository with no root application"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t echo "include erlang.mk" > $(APP)/Makefile

	$i "Create a new application named my_app"
	$t $(MAKE) -C $(APP) new-lib in=my_app $v

	$i "Create a new library named my_lib"
	$t $(MAKE) -C $(APP) new-lib in=my_lib $v

	$i "Add my_lib as LOCAL_DEPS of my_app"
	$t echo "LOCAL_DEPS = my_lib" >> $(APP)/apps/my_app/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/apps/my_lib/include/
	$t touch $(APP)/apps/my_lib/include/blue.hrl $(APP)/apps/my_lib/include/red.hrl $(APP)/apps/my_lib/include/pill.hrl
	$t echo "-include(\"pill.hrl\")." > $(APP)/apps/my_lib/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"my_lib/include/blue.hrl\")." > $(APP)/apps/my_app/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"my_lib/include/red.hrl\")." > $(APP)/apps/my_app/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/apps/my_app/my_app.d \
		$(APP)/apps/my_app/ebin/my_app.app \
		$(APP)/apps/my_app/ebin/use_red.beam \
		$(APP)/apps/my_app/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/apps/my_lib/include/pill.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP)/apps/my_app -type f -newer $(APP)/apps/my_lib/include/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/apps/my_lib/Makefile
	$t test -f $(APP)/apps/my_lib/include/blue.hrl
	$t test -f $(APP)/apps/my_lib/include/red.hrl
	$t test -f $(APP)/apps/my_lib/include/pill.hrl
	$t test -f $(APP)/apps/my_app/Makefile
	$t test -f $(APP)/apps/my_app/src/use_blue.erl
	$t test -f $(APP)/apps/my_app/src/use_red.erl
ifdef LEGACY
	$t test -f $(APP)/apps/my_lib/src/my_lib.app.src
	$t test -f $(APP)/apps/my_app/src/my_app.app.src
endif

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/apps/my_lib/my_app.d
	$t test ! -e $(APP)/apps/my_lib/ebin/
	$t test ! -e $(APP)/apps/my_app/my_app.d
	$t test ! -e $(APP)/apps/my_app/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-include-lib-src: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$t touch $(APP)/src/blue.hrl $(APP)/src/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/src/blue.hrl
	$t test -f $(APP)/src/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-include-lib-src-recursive: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files"
	$t touch $(APP)/src/blue.hrl $(APP)/src/pill.hrl
	$t echo "-include_lib(\"pill.hrl\")." > $(APP)/src/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch the deepest .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl and pill.hrl.
	$t printf "%s\n" \
		$(APP)/$(APP).d \
		$(APP)/ebin/$(APP).app \
		$(APP)/ebin/use_red.beam \
		$(APP)/src/use_red.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/src/pill.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP) -type f -newer $(APP)/src/pill.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/src/blue.hrl
	$t test -f $(APP)/src/pill.hrl
	$t test -f $(APP)/src/red.hrl
ifdef LEGACY
	$t test -f $(APP)/src/$(APP).app.src
endif
	$t test -f $(APP)/src/use_blue.erl
	$t test -f $(APP)/src/use_red.erl

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/$(APP).d
	$t test ! -e $(APP)/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/$(APP).d
	$t test -f $(APP)/ebin/$(APP).app
	$t test -f $(APP)/ebin/use_blue.beam
	$t test -f $(APP)/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/ebin/ -eval " \
		ok = application:start($(APP)), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key($(APP), modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-hrl-deps: init

	$i "Create a multi application repository with no root application"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t echo "include erlang.mk" > $(APP)/Makefile

	$i "Create a new application named my_app"
	$t $(MAKE) -C $(APP) new-lib in=my_app $v

	$t echo "DEPS = cowlib" > $(APP)/apps/my_app/Makefile
	$t echo "dep_cowlib_commit = master" >> $(APP)/apps/my_app/Makefile
	$t echo "include ../../erlang.mk" >> $(APP)/apps/my_app/Makefile
	$t printf "%s\n" "-module(boy)." "-include_lib(\"cowlib/include/cow_inline.hrl\")." > $(APP)/apps/my_app/src/boy.erl
	$t printf "%s\n" "-module(girl)." > $(APP)/apps/my_app/src/girl.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/boy.beam
	$t test -f $(APP)/apps/my_app/ebin/girl.beam
	$t test -f $(APP)/deps/cowlib/ebin/cowlib.app

ifndef LEGACY
	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/*/ebin/ -eval " \
		ok = application:load(my_app), \
		{ok, MyAppDeps} = application:get_key(my_app, applications), \
		true = lists:member(cowlib, MyAppDeps), \
		halt()"
endif

	$i "Touch cowlib .hrl file; check that only required files are rebuilt"
	$t printf "%s\n" \
		$(APP)/apps/my_app/my_app.d \
		$(APP)/apps/my_app/ebin/my_app.app \
		$(APP)/apps/my_app/ebin/boy.beam \
		$(APP)/apps/my_app/src/boy.erl | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/deps/cowlib/include/cow_inline.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP)/apps/my_app -type f -newer $(APP)/deps/cowlib/include/cow_inline.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Clean Cowlib"
	$t $(MAKE) -C $(APP)/deps/cowlib clean $v

	$i "Check that Cowlib compiled files were removed"
	$t test ! -e $(APP)/deps/cowlib/ebin/cowlib.app

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that Cowlib compiled files exist"
	$t test -f $(APP)/deps/cowlib/ebin/cowlib.app

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that Cowlib is still here"
	$t test -d $(APP)/deps/cowlib

	$i "Check that all relevant files were removed"
	$t test ! -e $(APP)/apps/my_app/my_app.d
	$t test ! -e $(APP)/apps/my_app/ebin/my_app.app
	$t test ! -e $(APP)/apps/my_app/ebin/boy.beam
	$t test ! -e $(APP)/apps/my_app/ebin/girl.beam

	$i "Distclean the application"
	$t $(MAKE) -C $(APP) distclean $v

	$i "Check that all relevant files were removed"
	$t test ! -e $(APP)/deps

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/boy.beam
	$t test -f $(APP)/apps/my_app/ebin/girl.beam
	$t test -d $(APP)/deps/cowlib

ifndef LEGACY
	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/*/ebin/ -eval " \
		ok = application:load(my_app), \
		{ok, MyAppDeps} = application:get_key(my_app, applications), \
		true = lists:member(cowlib, MyAppDeps), \
		halt()"
endif

core-app-hrl-include-loop: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files with header loop"
	$t mkdir $(APP)/include/
	$t printf "%s\n" "-include(\"blue.hrl\")." > $(APP)/include/red.hrl
	$t printf "%s\n" "-include(\"red.hrl\")." > $(APP)/include/blue.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application. Compilation should fail"
	$t ! $(MAKE) -C $(APP) $v

	$i "Check .d file"
	$t grep -q "src/use_blue.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d
	$t grep -q "src/use_red.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d

core-app-hrl-include_lib-loop: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files with heaeder loop"
	$t mkdir $(APP)/include/
	$t printf "%s\n" "-include_lib(\"blue.hrl\")." > $(APP)/include/red.hrl
	$t printf "%s\n" "-include_lib(\"red.hrl\")." > $(APP)/include/blue.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application. Compilation should fail"
	$t ! $(MAKE) -C $(APP) $v

	$i "Check .d file"
	$t grep -q "src/use_blue.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d
	$t grep -q "src/use_red.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d

core-app-hrl-include-loop-define-protected: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files with hrl loop protection "
	$t mkdir $(APP)/include/
	$t printf "%s\n" "-ifndef(BLUE_HRL_LOADED)." "-define(BLUE_HRL_LOADED,true)." "-include(\"red.hrl\")." "-endif." > $(APP)/include/blue.hrl
	$t printf "%s\n" "-ifndef(RED_HRL_LOADED)." "-define(RED_HRL_LOADED,true)." "-include(\"blue.hrl\")." "-endif." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application. Compilation should fail"
	$t ! $(MAKE) -C $(APP) $v ; ret=$$?

	$i "Check .d file"
	$t grep -q "src/use_blue.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d
	$t grep -q "src/use_red.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d

core-app-hrl-include_lib-loop-define-protected: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .hrl files with hrl loop protection "
	$t mkdir $(APP)/include/
	$t printf "%s\n" "-ifndef(BLUE_HRL_LOADED)." "-define(BLUE_HRL_LOADED,true)." "-include_lib(\"red.hrl\")." "-endif." > $(APP)/include/blue.hrl
	$t printf "%s\n" "-ifndef(RED_HRL_LOADED)." "-define(RED_HRL_LOADED,true)." "-include_lib(\"blue.hrl\")." "-endif." > $(APP)/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"blue.hrl\")." > $(APP)/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"red.hrl\")." > $(APP)/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v ; ret=$$?

	$i "Check .d file"
	$t grep -q "src/use_blue.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d
	$t grep -q "src/use_red.erl:: include/blue.hrl include/red.hrl; @touch" $(APP)/$(APP).d

core-app-hrl-multiapps-include-loop-define-protected: init

	$i "Create a multi application repository with no root application"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t echo "include erlang.mk" > $(APP)/Makefile

	$i "Create a new application named my_app"
	$t $(MAKE) -C $(APP) new-lib in=my_app $v

	$i "Create a new library named my_lib"
	$t $(MAKE) -C $(APP) new-lib in=my_lib $v

	$i "Add my_lib as LOCAL_DEPS of my_app"
	$t echo "LOCAL_DEPS = my_lib" >> $(APP)/apps/my_app/Makefile

	$i "Generate .hrl files"
	$t mkdir $(APP)/apps/my_lib/include/
	$t printf "%s\n" "-ifndef(BLUE_HRL_LOADED)." "-define(BLUE_HRL_LOADED,true)." "-include_lib(\"red.hrl\")." "-endif." > $(APP)/apps/my_lib/include/blue.hrl
	$t printf "%s\n" "-ifndef(RED_HRL_LOADED)." "-define(RED_HRL_LOADED,true)." "-include_lib(\"blue.hrl\")." "-endif." > $(APP)/apps/my_lib/include/red.hrl

	$i "Generate .erl files dependent from headers"
	$t printf "%s\n" "-module(use_blue)." "-include_lib(\"my_lib/include/blue.hrl\")." > $(APP)/apps/my_app/src/use_blue.erl
	$t printf "%s\n" "-module(use_red)." "-include_lib(\"my_lib/include/red.hrl\")." > $(APP)/apps/my_app/src/use_red.erl

	$i "Build the application"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Touch one .hrl file; check that only required files are rebuilt"
# The use_red.erl gets touched because of its dependency to red.hrl.
	$t printf "%s\n" \
		$(APP)/apps/my_app/my_app.d \
		$(APP)/apps/my_app/ebin/my_app.app \
		$(APP)/apps/my_app/ebin/use_red.beam \
		$(APP)/apps/my_app/src/use_red.erl \
		$(APP)/apps/my_app/src/use_blue.erl \
		$(APP)/apps/my_app/ebin/use_blue.beam | sort > $(APP)/EXPECT
	$t $(SLEEP)
	$t touch $(APP)/apps/my_lib/include/red.hrl
	$t $(SLEEP)
	$t $(MAKE) -C $(APP) $v
	$t find $(APP)/apps/my_app -type f -newer $(APP)/apps/my_lib/include/red.hrl | sort | diff $(APP)/EXPECT -
	$t rm $(APP)/EXPECT

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

	$i "Clean the application"
	$t $(MAKE) -C $(APP) clean $v

	$i "Check that source files still exist"
	$t test -f $(APP)/Makefile
	$t test -f $(APP)/erlang.mk
	$t test -f $(APP)/apps/my_lib/Makefile
	$t test -f $(APP)/apps/my_lib/include/blue.hrl
	$t test -f $(APP)/apps/my_lib/include/red.hrl
	$t test -f $(APP)/apps/my_app/Makefile
	$t test -f $(APP)/apps/my_app/src/use_blue.erl
	$t test -f $(APP)/apps/my_app/src/use_red.erl
ifdef LEGACY
	$t test -f $(APP)/apps/my_lib/src/my_lib.app.src
	$t test -f $(APP)/apps/my_app/src/my_app.app.src
endif

	$i "Check that all build artifacts are removed"
	$t test ! -e $(APP)/apps/my_lib/my_app.d
	$t test ! -e $(APP)/apps/my_lib/ebin/
	$t test ! -e $(APP)/apps/my_app/my_app.d
	$t test ! -e $(APP)/apps/my_app/ebin/

	$i "Build the application again"
	$t $(MAKE) -C $(APP) $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/apps/my_app/my_app.d
	$t test -f $(APP)/apps/my_app/ebin/my_app.app
	$t test -f $(APP)/apps/my_app/ebin/use_blue.beam
	$t test -f $(APP)/apps/my_app/ebin/use_red.beam

	$i "Check that the application was compiled correctly"
	$t $(ERL) -pa $(APP)/apps/my_app/ebin/ $(APP)/apps/my_lib/ebin/ -eval " \
		{ok, _Apps } = application:ensure_all_started(my_app), \
		{ok, Mods = [use_blue, use_red]} \
			= application:get_key(my_app, modules), \
		[{module, M} = code:load_file(M) || M <- Mods], \
		halt()"

core-app-test-build-outofdate-files-only: init

	$i "Bootstrap a new OTP library named $(APP)"
	$t mkdir $(APP)/
	$t cp ../erlang.mk $(APP)/
	$t $(MAKE) -C $(APP) -f erlang.mk bootstrap-lib $v

	$i "Generate .erl test files"
	$t mkdir $(APP)/test/
	$t printf "%s\n" "-module(use_blue)." > $(APP)/test/use_blue.erl
	$t printf "%s\n" "-module(use_red)." > $(APP)/test/use_red.erl

	$i "Build the application testsuite"
	$t $(MAKE) -C $(APP) test-build $v

	$i "Check that all compiled files exist"
	$t test -f $(APP)/test/use_blue.beam
	$t test -f $(APP)/test/use_red.beam

	$t $(SLEEP)
	$t touch $(APP)/build-1

	$i "Re-un the make command; check that nothing is rebuilt"
	$t $(MAKE) -C $(APP) test-build $v
	$t test $(APP)/test/use_blue.beam -ot $(APP)/build-1
	$t test $(APP)/test/use_red.beam -ot $(APP)/build-1

	$i "Touch one .erl file; check that only required files are rebuilt"
	$t $(SLEEP)
	$t touch $(APP)/test/use_blue.erl
	$t $(MAKE) -C $(APP) test-build $v
	$t test $(APP)/test/use_blue.beam -nt $(APP)/build-1
	$t test $(APP)/test/use_red.beam -ot $(APP)/build-1

	$t touch $(APP)/build-2

	$i "Touch one Makefile; check that all files are rebuilt"
	$t $(SLEEP)
	$t touch $(APP)/Makefile
	$t $(MAKE) -C $(APP) test-build $v
	$t test $(APP)/test/use_blue.beam -nt $(APP)/build-2
	$t test $(APP)/test/use_red.beam -nt $(APP)/build-2

	$i "Add a syntax error to the test; check that the build fails"
	$t $(SLEEP)
	$t echo "garbage" >> $(APP)/test/use_blue.erl
	$t ! $(MAKE) -C $(APP) test-build $v
	$t ! test -f $(APP)/test/use_blue.beam
