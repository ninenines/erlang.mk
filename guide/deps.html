<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Erlang.mk User Guide</title>
<style type="text/css"><!--
body{background:white;color:black;font-family:"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;justify-content:center;margin:0 auto;padding:0;width:600px}
header {align-items:center;display:flex;justify-content:center}
header nav.left{text-align:right;width:150px}
header nav.right{text-align:left;width:150px}
header nav a{display:block;margin:1.5em 1em}
main{margin-top:2em;text-align:justify}
main h2, main h3{margin-top:2em}
main h1, main div.chapter>div.titlepage h2{font-size:2em;margin-top:.67em}
a{color:#d9230f;text-decoration:none}
a:hover{text-decoration:underline}
a.xref{display:none}
h1, h2, h3{font-weight:normal}
div.navfooter{margin-bottom:1em}
--></style>
</head>
<body>
<header>
	<nav class="left">
		<a href="index.html">User guide</a>
		<a href="getting_started.html">Tutorials</a>
	</nav>
	<a href="/" class="logo"><img src="../res/logo-small.png" alt="Erlang.mk" title="Erlang.mk: A build tool for Erlang that just works" height="200" width="206"/></a>
	<nav class="right">
		<a href="https://github.com/ninenines/erlang.mk/tree/master/index">470+ packages</a>
		<a href="https://github.com/ninenines/erlang.mk/issues">Issues?</a>
	</nav>
</header>
<main>

<div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="building.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ports.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="deps"></a>Chapter 7. Packages and dependencies</h2></div></div></div><p>Erlang.mk can fetch and compile the dependencies that your
project requires. Erlang.mk improves upon the concepts
introduced by Rebar, so they should be familiar to many
seasoned Erlang developers.</p><p>Erlang.mk is not a package manager, nor is it trying to be,
but it does include an index of Erlang packages to make
discovering useful projects easier.</p><p>This chapter will explain how to use packages, add
dependencies to your project or bundle them directly
in a single repository.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_searching_packages"></a>7.1. Searching packages</h2></div></div></div><p>Erlang.mk gives you access to nearly 500 packages, with more
being added regularly.</p><p>To find a package, search for it:</p><pre class="programlisting">$ make search q=pool</pre><p>This will return all packages matching this word, like worker
pool and acceptor pool projects.</p><p>You can also list everything and use regular command line
tools to find what you need, for example:</p><pre class="programlisting">$ make search | less</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_adding_dependencies_to_your_project"></a>7.2. Adding dependencies to your project</h2></div></div></div><p>Once you find the package you need, adding it as a dependency
to your project is a one-liner:</p><pre class="programlisting">DEPS = cowboy</pre><p>And that’s it! The next time you run <code class="literal">make</code>, Erlang.mk will
fetch and compile Cowboy. Erlang.mk will also ensure Cowboy
is available whenever you use the shell, run tests and any
other operations.</p><p>Note though that you may need to specify the version of a
dependency to use. Otherwise, you may get an outdated version,
since the package index used by Erlang.mk is not always
updated with the latest version of each package.</p><pre class="programlisting">DEPS = cowboy
dep_cowboy_commit = 2.8.0</pre><p>Erlang.mk will fill in the application resource file with
all applications found in <code class="literal">DEPS</code>. But not all dependencies
are Erlang applications, and not all dependencies need to
be a runtime dependency. That’s where the <code class="literal">BUILD_DEPS</code>
variable comes in: it works just like <code class="literal">DEPS</code>, except the
dependencies listed there will not be added as runtime
dependencies.</p><p>For example, you could add a parse transform project like
this to make it available only at build time:</p><pre class="programlisting">BUILD_DEPS = erlando</pre><p>Or you could depend on a C project directly, if you are
building a NIF:</p><pre class="programlisting">BUILD_DEPS = leveldb
dep_leveldb = git https://github.com/basho/leveldb 2.1.3</pre><p>This dependency will be built before your application, so
you could easily copy the resulting shared file into your
<span class="emphasis"><em>priv/</em></span> directory as part of the build process. More information
about that in the <a class="link" href="ports.html" title="Chapter 8. NIFs and port drivers">NIFs and port drivers</a>
chapter.</p><p>Another variable, <code class="literal">LOCAL_DEPS</code>, allows specifying runtime
dependencies which are part of Erlang/OTP itself, but also
dependencies that are included in the repository. Since they
are already on your system, there is no need to fetch them.
Do note that there is no way to choose the version, the
application used will be the one already on your system.</p><p>You could depend on the Crypto application, for example:</p><pre class="programlisting">LOCAL_DEPS = crypto</pre><p>Erlang.mk comes with additional types of dependencies.
It has <code class="literal">TEST_DEPS</code> for dependencies used only for testing:</p><pre class="programlisting">TEST_DEPS = ct_helper
dep_ct_helper = git https://github.com/ninenines/ct_helper master</pre><p><code class="literal">DOC_DEPS</code> for dependencies used only when building documentation:</p><pre class="programlisting">DOC_DEPS = edown</pre><p><code class="literal">REL_DEPS</code> for dependencies required to build the release,
or to include extra applications in the release:</p><pre class="programlisting">REL_DEPS = recon</pre><p>And <code class="literal">SHELL_DEPS</code> for dependencies to make available when running
the <code class="literal">make shell</code> command:</p><pre class="programlisting">SHELL_DEPS = tddreloader</pre><p>All these will be documented in more details in their respective
chapters.</p><p>Note that these additional types of dependencies will only
be fetched after normal dependencies by default. You can
force a dependency to be downloaded first by extending the
target <code class="literal">deps::</code> before including <span class="emphasis"><em>erlang.mk</em></span>, for example:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
deps
</span></dt><dd>
$(CURDIR)/deps/triq
</dd></dl></div><p>Sometimes dependencies are allowed to be missing. However, your application
may depend on an optional application being started. To ensure that an
optional dependency is started before your application, the variable
<code class="literal">OPTIONAL_DEPS</code> may be used:</p><pre class="programlisting">OPTIONAL_DEPS = quicer</pre><p>The top-level project can then decide whether to include this
application by adding it to its <code class="literal">BUILD_DEPS</code> and including
it in the release dependencies.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_modifying_the_dependency_source_or_version"></a>7.2.1. Modifying the dependency source or version</h3></div></div></div><p>By default, Erlang.mk will look into its package index to
find the project you are looking for, if you only provide
its name. This is this case:</p><pre class="programlisting">DEPS = cowboy</pre><p>If you need a different version, you need to define another
variable. There are two ways to do this, each being useful
for different reasons.</p><p>If you simply want to change the commit number, all you
need to do is to define the <code class="literal">dep_$(DEP_NAME)_commit</code>
variable. In the case of Cowboy, this would look like this:</p><pre class="programlisting">DEPS = cowboy
dep_cowboy_commit = 2.12.0</pre><p>Erlang.mk will use the package index to get all information
about Cowboy, except the commit number which will be overridden.</p><p>If you need to set the fetch method or repository information
too, for example because you want to use your own fork, or
simply because the project is missing from the index, you
can define the <code class="literal">dep_$(DEP_NAME)</code> variable with everything:</p><pre class="programlisting">DEPS = cowboy
dep_cowboy = git https://github.com/essen/cowboy 2.12.0</pre><p>This will fetch Cowboy from your fork at the given commit.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_fetch_methods"></a>7.2.2. Fetch methods</h3></div></div></div><p>Erlang.mk comes with a number of different fetch methods.
You can fetch from Git, Mercurial, SVN, to name a few.
There are fetch methods that will work everywhere, and
fetch methods that will only work in a given environment.</p><p>The following table lists all existing methods:</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Name           </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"> Format            </th><th style="border-bottom: 1px solid #527bbd; " align="center" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>git</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>git repo commit</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Clone the Git repository and checkout the given version</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>git-subfolder</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>git repo commit subfolder</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Clone the Git repository, checkout the given version and use one of its subfolders as a dependency</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>git-submodule</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>git-submodule</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Initialize and update the Git submodule</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>hg</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>hg repo commit</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Clone the Mercurial repository and update to the given version</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>svn</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>svn repo</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Checkout the given SVN repository</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>cp</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>cp path/to/repo</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Recursively copy a local directory</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>ln</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>ln path/to/repo</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Symbolically link a local directory</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>hex</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>hex version [pkg]</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Download the given project version from hex.pm</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>fail</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>N/A</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Always fail, reserved for internal use</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>legacy</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>N/A</p></td><td style="border-bottom: 1px solid #527bbd; " align="center" valign="top"><p>Legacy Erlang.mk fetcher, reserved for internal use</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>default</p></td><td style="border-right: 1px solid #527bbd; " align="center" valign="top"><p>N/A</p></td><td style="" align="center" valign="top"><p>Reserved</p></td></tr></tbody></table></div><p>The <code class="literal">git</code> and <code class="literal">hg</code> methods both have a repository and commit.
You can use any valid commit, tag or branch in that repository
for the commit value.</p><p>For example, to fetch Cowboy with tag 2.0.0-pre.2 from Git:</p><pre class="programlisting">dep_cowboy = git https://github.com/ninenines/cowboy 2.0.0-pre.2</pre><p>Or to fetch Ehsa tag 4.0.3 from Mercurial:</p><pre class="programlisting">dep_ehsa = hg https://bitbucket.org/a12n/ehsa 4.0.3</pre><p>Git also comes with a concept of submodules. Erlang.mk can
automatically initializes and updates submodules for dependencies,
as long as they were added beforehand using <code class="literal">git submodule add</code>:</p><pre class="programlisting">dep_cowboy = git-submodule</pre><p>The <code class="literal">svn</code> method only has a repository value, but that’s
simply because the SVN repository URL can also contain
the path and commit.</p><p>This would fetch an example project from the trunk:</p><pre class="programlisting">dep_ex1 = svn https://example.com/svn/trunk/project/ex1</pre><p>And this would fetch a separate example project from a
specific commit:</p><pre class="programlisting">dep_ex2 = svn svn://example.com/svn/branches/erlang-proj/ex2@264</pre><p>You can copy a directory from your machine using the <code class="literal">cp</code> method.
It only takes the path to copy from:</p><pre class="programlisting">dep_cowboy = cp $(HOME)/ninenines/cowboy</pre><p>Finally, you can use a package from the
<a class="ulink" href="https://hex.pm/" target="_top">Hex repository</a>:</p><pre class="programlisting">dep_cowboy = hex 1.0.3</pre><p>If the package on Hex has a different name than the application,
you can provide it after the version:</p><pre class="programlisting">dep_uuid = hex 1.7.5 uuid_erl</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_custom_fetch_methods"></a>7.2.3. Custom fetch methods</h3></div></div></div><p>If none of the existing methods fit your use, you can simply
define your own. Erlang.mk will consider all variables that
are named as <code class="literal">dep_fetch_$(METHOD)</code> to be available fetch
methods. You can do anything inside this variable, as long
as you create a folder named <span class="emphasis"><em>$(DEPS_DIR)/$(call query_name,$1)</em></span>.
Or in layman terms, if your dependency is Cowboy, this would
become <span class="emphasis"><em>deps/cowboy</em></span>.</p><p>To give an example, this is what the Git method does:</p><pre class="programlisting">define dep_fetch_git
    git clone -q -n -- $(call query_repo_git,$1) $(DEPS_DIR)/$(call query_name,$1); \
    cd $(DEPS_DIR)/$(call query_name,$1) &amp;&amp; git checkout -q $(call query_version_git,$1);
endef</pre><p>Note that, like dependency information, this custom fetch method
must be written before including <span class="emphasis"><em>erlang.mk</em></span>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_how_deps_are_fetched_and_built"></a>7.3. How deps are fetched and built</h2></div></div></div><p>The order in which dependencies are fetched and built is well
defined. This means that Erlang.mk will get the same applications
regardless of the command or options being used.</p><p>In tree traversal terms, where the list of dependencies is a
tree, Erlang.mk fetches everything using the pre-order traversal
method. The steps can be summarized like this, starting from
the root application:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Fetch all dependencies for the application
</li><li class="listitem">
Build first dependency
</li><li class="listitem">
Build Nth dependency
</li><li class="listitem">
Build last dependency
</li></ol></div><p>Every time a dependency is built, these same steps are followed,
recursively.</p><p>Do note that the first step, fetching all dependencies of
an application, is not guaranteed to be ordered. The reason
for this is that it is not possible to have the same dependency
listed twice in a single application, and therefore there can
be no conflicts. Remember, this step only fetches, at no point
are different applications built in parallel.</p><p>What about conflicts between the dependencies of different
applications? Simple. Since builds are ordered, this means
that the first version of an application that is fetched
will be the one that wins.</p><p>This means that if project A depends on projects B and C,
in this order, and that both B and C depend on a different
version of D, it will always be B’s version of D that wins,
because we fetch the dependencies of B before fetching
those from C.</p><p>Similarly, if project A depends on projects B, C and D,
regardless of the order, and A, B and C depend on a
different version of D, it will always be A’s version
that wins, because we fetch all dependencies of A before
fetching those from B or C.</p><p>Once a dependency is built, it will not be built again by
default. Typically dependencies do not need to be recompiled
and this speeds up building immensely. There are a few ways
to force recompiling a dependency however:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The dependency directory is a symbolic link; the dependency
  will always be recompiled.
</li><li class="listitem">
The dependency is built directly, for example with a command
  like <code class="literal">make -C deps/cowlib</code>, or <code class="literal">make</code> in the dependency’s
  directory.
</li><li class="listitem">
The variable <code class="literal">FULL</code> is set, for example <code class="literal">make FULL=1</code>. This
  will force building of all dependencies. This can be added
  to your Makefile before including <span class="emphasis"><em>erlang.mk</em></span>.
</li><li class="listitem">
The file <code class="literal">ebin/dep_built</code> in the dependency is removed.
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_fetching_and_listing_dependencies_only"></a>7.4. Fetching and listing dependencies only</h2></div></div></div><p>You can fetch all dependencies recursively without building anything,
with the <code class="literal">make fetch-deps</code> command. It follows the same rules described
in the section above.</p><p>You can list all dependencies recursively, again without building
anything, with the <code class="literal">make list-deps</code> command. It will obviously need
to fetch all dependencies exactly like <code class="literal">make fetch-deps</code>. Once
everything is fetched, it prints a sorted list of absolute paths to the
dependencies.</p><p>By default, <code class="literal">fetch-deps</code> and <code class="literal">list-deps</code> work on the <code class="literal">BUILD_DEPS</code>
and <code class="literal">DEPS</code> lists only. To also fetch/list <code class="literal">TEST_DEPS</code>, <code class="literal">DOC_DEPS</code>,
<code class="literal">REL_DEPS</code> and/or <code class="literal">SHELL_DEPS</code>, you have two possibilities:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
You can use <code class="literal">make fetch-test-deps</code>, <code class="literal">make fetch-doc-deps</code>, <code class="literal">make
  fetch-rel-deps</code> and <code class="literal">make fetch-shell-deps</code> commands respectively.
  If you want to list them, you can use <code class="literal">make list-test-deps</code>, <code class="literal">make
  list-doc-deps</code>, <code class="literal">make list-rel-deps</code> and <code class="literal">make list-shell-deps</code>
  respectively.
</li><li class="listitem">
You can use <code class="literal">make fetch-deps</code> or <code class="literal">make list-deps</code> with the Makefile
  variable <code class="literal">DEP_TYPES</code> set to a list of dependency types you want.
  The types are <code class="literal">test</code>, <code class="literal">doc</code>, <code class="literal">rel</code> and <code class="literal">shell</code> respectively. For
  example, you can list test and doc dependencies with <code class="literal">make list-deps
  DEP_TYPES='test doc'</code>.
</li></ul></div><p>Note that only first level ‘TEST_DEPS<code class="literal">, `DOC_DEPS</code>, <code class="literal">REL_DEPS</code> and
<code class="literal">SHELL_DEPS</code> are included, not dependencies’ one. In other word,
<code class="literal">make list-test-deps</code> lists the <code class="literal">TEST_DEPS</code> of your project, but not
<code class="literal">TEST_DEPS</code> of the projects yours depend on.</p><p>No matter which method you use, <code class="literal">BUILD_DEPS</code> and <code class="literal">DEPS</code> are always
included.</p><p>Internally, the <code class="literal">make fetch-*</code> commands store the complete list of
dependencies in files named <code class="literal">$(ERLANG_MK_RECURSIVE_DEPS_LIST)</code>,
<code class="literal">$(ERLANG_MK_RECURSIVE_TEST_DEPS_LIST)</code>,
<code class="literal">$(ERLANG_MK_RECURSIVE_DOC_DEPS_LIST)</code>,
<code class="literal">$(ERLANG_MK_RECURSIVE_REL_DEPS_LIST)</code> and
<code class="literal">$(ERLANG_MK_RECURSIVE_SHELL_DEPS_LIST)</code>. Those files are simply printed
by the <code class="literal">make list-*</code> commands.</p><p><code class="literal">make list-*</code> commands are made for human beings. If you need the list
of dependencies in a Makefile or a script, you should use the content
of those files directly instead. The reason is that <code class="literal">make fetch-*</code> and
<code class="literal">make list-*</code> may have unwanted content in their output, such as actual
fetching of dependencies.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_querying_dependencies"></a>7.5. Querying dependencies</h2></div></div></div><p>You can obtain information about all dependencies with
the <code class="literal">make query-deps</code> family of commands:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">make query-deps</code> will list dependencies found in <code class="literal">BUILD_DEPS</code>
  and <code class="literal">DEPS</code> recursively.
</li><li class="listitem">
<code class="literal">make query-doc-deps</code> will list documentation dependencies
  of the current project.
</li><li class="listitem">
<code class="literal">make query-rel-deps</code> will list release dependencies
  of the current project.
</li><li class="listitem">
<code class="literal">make query-shell-deps</code> will list shell dependencies
  of the current project.
</li><li class="listitem">
<code class="literal">make query-test-deps</code> will list test dependencies
  of the current project.
</li></ul></div><p>By default the information printed will be the dependency name,
fetch method, repository and version, prefixed by the current
project’s name. But this output can be customized via the
variable <code class="literal">QUERY</code>:</p><pre class="programlisting">$ make query-deps QUERY="name fetch_method repo version extra absolute_path"</pre><p>The following options are available:</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
name
</span></dt><dd>
The dependency name.
</dd><dt><span class="term">
fetch_method
</span></dt><dd>
The dependency’s fetch method.
</dd><dt><span class="term">
repo
</span></dt><dd>
The dependency’s repository.
</dd><dt><span class="term">
version
</span></dt><dd>
The dependency’s version, tag or commit.
</dd><dt><span class="term">
extra
</span></dt><dd>
Any additional information specific to the fetch method used.
</dd><dt><span class="term">
absolute_path
</span></dt><dd>
The dependency’s location after it has been fetched.
</dd></dl></div><p>Fields that have no value will print <code class="literal">-</code>. For example
not all fetch methods have a value for the <code class="literal">version</code>.</p><p>The value for <code class="literal">extra</code>, when available, will be formatted
with the name of the information printed prefixed. For
example the hex fetch method will add
<code class="literal">package-name=uuid_erl</code> for the <code class="literal">uuid</code> application.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_ignoring_unwanted_dependencies"></a>7.6. Ignoring unwanted dependencies</h2></div></div></div><p>Sometimes, you may want to ignore dependencies entirely.
Not even fetch them. You may want to do this because a
project you depend on depends on an application you do
not need (like a dependency for building documentation
or testing). Or maybe the dependency is already installed
on your system.</p><p>To ignore a dependency, simply add it to the <code class="literal">IGNORE_DEPS</code>
variable:</p><pre class="programlisting">IGNORE_DEPS += edown proper</pre><p>This will only ignore dependencies that are needed for
building. It is therefore safe to write:</p><pre class="programlisting">IGNORE_DEPS += edown proper
TEST_DEPS = proper</pre><p>The PropEr application will be fetched as intended when
running <code class="literal">make tests</code> or <code class="literal">make check</code>. It will however
not be fetched when running <code class="literal">make</code> or <code class="literal">make deps</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_dependencies_directory"></a>7.7. Dependencies directory</h2></div></div></div><p>Dependencies are fetched in <span class="emphasis"><em>$(DEPS_DIR)</em></span>. By default this is
the <span class="emphasis"><em>deps</em></span> directory. You can change this default, but you
should only do so if it was not defined previously. Erlang.mk
uses this variable to tell dependencies where to fetch their
own dependencies.</p><p>You will therefore need to use <code class="literal">?=</code> instead of <code class="literal">=</code>. Of course,
if you know you will never use this project as a dependency,
<code class="literal">=</code> will work. But to avoid it biting you later on, do this:</p><pre class="programlisting">DEPS_DIR ?= $(CURDIR)/libs</pre><p>The <code class="literal">$(CURDIR)</code> part is important, otherwise dependencies of
dependencies will be fetched in the wrong directory.</p><p>Erlang.mk will also export the <code class="literal">REBAR_DEPS_DIR</code> variable for
compatibility with Rebar build tools, as long as they are
recent enough.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_many_applications_in_one_repository"></a>7.8. Many applications in one repository</h2></div></div></div><p>In addition to the dependencies that are fetched, Erlang.mk
also allows you to have dependencies local to your repository.
This kind of layout is sometimes called multi-application
repositories, or repositories with multiple applications.</p><p>They work exactly the same as remote dependencies, except:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
They are not fetched
</li><li class="listitem">
They are not autopatched
</li><li class="listitem">
They are not deleted on <code class="literal">make distclean</code>
</li><li class="listitem">
They are not automatically added to the application resource file
</li></ul></div><p>To properly fill the application resource file and compile apps in
the right order, you will need to define the <code class="literal">LOCAL_DEPS</code> variable
for each relevant application, the same as for OTP applications. Apps
can depend on each other in this way, and their compilation order
will follow the same rules as regular dependencies in <code class="literal">DEPS</code>.</p><p>The top-level <code class="literal">LOCAL_DEPS</code> variable, if defined, will determine which
apps (along with their dependencies) to build, and also which apps
should be added to the top-level application resource file, if there
is one. This may be useful, for example, for specifying a different
set of apps to build for different releases. If <code class="literal">LOCAL_DEPS</code> is not
defined, then all apps in the <span class="emphasis"><em>$(APPS_DIR)</em></span> will be built, but none
will be automatically added to the top-level application resource
file.</p><p>If there is a conflict between a local dependency and a
remote dependency, then the local dependency always wins;
an error will be triggered when trying to fetch the
conflicting remote dependency.</p><p>To start using dependencies local to the repository, simply
create a folder named <span class="emphasis"><em>$(APPS_DIR)</em></span>. By default, this folder
is the <span class="emphasis"><em>apps/</em></span> directory.</p><p>You can use Erlang.mk to bootstrap local dependencies by
using the command <code class="literal">make new-app</code> or <code class="literal">make new-lib</code>. This
command will create the necessary directories and bootstrap
the application.</p><p>For example, to create a full fledged OTP application as
a local dependency:</p><pre class="programlisting">$ make new-app in=webchat</pre><p>Or, the same as an OTP library:</p><pre class="programlisting">$ make new-lib in=webchat</pre><p>Templates also work with local dependencies, from the root
directory of the project. You do need however to tell
Erlang.mk to create the files in the correct application:</p><pre class="programlisting">$ make new t=gen_server n=my_server in=webchat</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_repositories_with_no_application_at_the_root_level"></a>7.9. Repositories with no application at the root level</h2></div></div></div><p>It’s possible to use Erlang.mk with only applications in
<span class="emphasis"><em>$(APPS_DIR)</em></span>, and nothing at the root of the repository.
Just create a folder, put the <span class="emphasis"><em>erlang.mk</em></span> file in it,
write a Makefile that includes it, and start creating
your applications.</p><p>Similarly, it’s possible to have a repository with only
dependencies found in <span class="emphasis"><em>$(DEPS_DIR)</em></span>. You just need to
create a Makefile and specify the dependencies you want.
This allows you to create a repository for handling the
building of releases, for example.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_autopatch"></a>7.10. Autopatch</h2></div></div></div><p>Erlang.mk will automatically patch all the dependencies it
fetches. It needs to do this to ensure that the dependencies
become compatible with not only Erlang.mk, but also with
the version of Erlang.mk that is currently used.</p><p>When fetching a dependency, the following operations are
performed:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Fetch the dependency using the configured fetch method
</li><li class="listitem">
If it contains a <span class="emphasis"><em>configure.ac</em></span> or <span class="emphasis"><em>configure.in</em></span> file, run <code class="literal">autoreconf -Wall -vif -I m4</code>
</li><li class="listitem">
If it contains a <span class="emphasis"><em>configure</em></span> script, run it
</li><li class="listitem">
Run autopatch on the project
</li></ul></div><p>Autopatch first checks if there is any project-specific patch
enabled. There are currently two: <code class="literal">ELIXIR_PATCH</code> for the <code class="literal">elixir</code>
dependency and <code class="literal">HUT_PATCH</code> for the <code class="literal">hut</code> dependency.</p><p>Otherwise, autopatch performs different operations depending
on the kind of project it finds the dependency to be.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Rebar projects are automatically converted to use Erlang.mk
as their build tool. This essentially patches Rebar out, and
fixes and converts the project to be compatible with Erlang.mk.
</li><li class="listitem">
Erlang.mk projects have their <span class="emphasis"><em>Makefile</em></span> patched, if necessary,
to include the top-level project’s Erlang.mk. This is to ensure
that functionality works across all dependencies, even if the
dependency’s Erlang.mk is outdated. The patched Makefile
can be safely committed if necessary.
</li><li class="listitem">
Other Erlang projects get a small Erlang.mk Makefile
generated automatically.
</li><li class="listitem">
Projects with no source directory and no Makefile get an
empty Makefile generated, for compatibility purposes.
</li><li class="listitem">
Other projects with no Makefile are left untouched.
</li></ul></div><p>You can add additional commands to be run immediately before
or after autopatch is done by extending the target
<code class="literal">autopatch-$(dep)::</code>, for example this would remove
a module:</p><pre class="programlisting">autopatch-ranch::
    rm -f $(DEPS_DIR)/ranch/src/ranch_proxy_header.erl</pre><p>A common use case for this feature is to apply a PATCH
file on the dependency immediately after fetching it.
It can also be used to add compiler options, for example:</p><pre class="programlisting">autopatch-couchbeam::
    printf "\nERLC_OPTS += -DWITH_JIFFY\n" &gt;&gt; $(DEPS_DIR)/couchbeam/Makefile</pre><p>The commands will run before autopatch when the target is
defined before including <span class="emphasis"><em>erlang.mk</em></span>, and after otherwise.</p><p>You can disable the replacing of the <span class="emphasis"><em>erlang.mk</em></span> file by
defining the <code class="literal">NO_AUTOPATCH_ERLANG_MK</code> variable:</p><pre class="programlisting">NO_AUTOPATCH_ERLANG_MK = 1</pre><p>You can also disable autopatch entirely for a few select
projects using the <code class="literal">NO_AUTOPATCH</code> variable:</p><pre class="programlisting">NO_AUTOPATCH = cowboy ranch cowlib</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_dealing_with_duplicate_modules"></a>7.11. Dealing with duplicate modules</h2></div></div></div><p>When there are duplicate modules found in both applications
and their dependencies, some tasks may fail. Erlang expects
modules to be unique in general.</p><p>When the duplicates are found in dependencies, you will need
to remove one of the duplicates at fetch time. To do so, you
can add a rule similar to this to your Makefile before including
<span class="emphasis"><em>erlang.mk</em></span>:</p><pre class="programlisting">DEPS_DIR = $(CURDIR)/deps

deps:: $(DEPS_DIR)/cowlib
    $(verbose) rm -f $(DEPS_DIR)/cowlib/src/cow_ws.erl</pre><p>This must be done from the application that has this dependency.
Only define the <code class="literal">DEPS_DIR</code> variable if necessary.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_skipping_deps"></a>7.12. Skipping deps</h2></div></div></div><p>It is possible to temporarily skip all dependency operations.
This is done by defining the <code class="literal">SKIP_DEPS</code> variable. Use cases
include being somewhere with no connection to download them,
or perhaps a peculiar setup.</p><p>A typical usage would be:</p><pre class="programlisting">$ make SKIP_DEPS=1</pre><p>When the variable is defined:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Dependencies will not be compiled or downloaded when required
</li><li class="listitem">
The dependency directory <span class="emphasis"><em>$(DEPS_DIR)</em></span> will not be removed on <code class="literal">make distclean</code>
</li></ul></div><p>This variable only applies to remote dependencies.</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="building.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="code.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ports.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> </td></tr></table></div>
</main>
</body>
</html>
